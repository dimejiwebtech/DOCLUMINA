class Post(BaseContent):
    category = models.ForeignKey('Category', on_delete=models.CASCADE, null=True, blank=True)


class Category(models.Model):
    category_name = models.CharField(max_length=100, unique=True)
    slug = models.SlugField(max_length=100, unique=True)
    description = models.TextField(max_length=200, null=True, blank=True)


<!-- Category -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="px-4 py-3 border-b border-gray-200">
                        <h3 class="text-lg font-medium text-gray-900">Category</h3>
                    </div>
                    <div class="p-4">
                        {{ form.category }}
                    </div>
                </div>

    const categorySelect = document.getElementById('id_category');
    if (categorySelect) {
      categorySelect.addEventListener('change', () => this.scheduleAutoSave());
    }

    const seoInput = document.getElementById('id_seo_description');
    if (seoInput) {
      seoInput.addEventListener('input', this.updateCharCounter.bind(this));
    }

  collectFormData() {
    const data = {
      category: document.getElementById('id_category')?.value || '',
    };

    if (this.postId) {
      data.post_id = this.postId;
    }

    return data;
  }

def add_post(request):
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES)
        if form.is_valid():
            post = form.save(commit=False)
            featured_image_id = request.POST.get('featured_image_id')
            if featured_image_id:
                try:
                    from media_manager.models import MediaFile  
                    media_obj = MediaFile.objects.get(id=featured_image_id)
                    post = form.save(commit=False)
                    post.featured_image = media_obj.file 
                except MediaFile.DoesNotExist:
                    pass
            else:
                post = form.save(commit=False)
            post.author = request.user
            
            # Handle status
            if 'save_draft' in request.POST:
                post.status = 'draft'
            elif 'publish' in request.POST:
                post.status = 'published'
                if not post.published_date:
                    post.published_date = timezone.now()
            
            # Generate slug if not provided
            if not post.slug and post.title:
                post.slug = generate_unique_slug(post.title)
            
            post.save()
            
            # Handle categories - get selected category IDs from POST data
            selected_categories = request.POST.getlist('category')
            if selected_categories:
                post.category.set(selected_categories)
            
            if post.status == 'published':
                messages.success(request, 'Post published successfully!')
            else:
                messages.success(request, 'Post saved as draft!')
                
            return redirect('edit_post', pk=post.pk)
        else:
            # Add form errors to messages
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
    else:
        form = PostForm()
    
    all_categories = Category.objects.all()
    return render(request, 'dashboard/add_post.html', {
        'form': form,
        'all_categories': all_categories,
    })

@login_required(login_url='login')
def edit_post(request, pk):
    post = get_object_or_404(Post, pk=pk)
    
    # Check if user owns the post or is superuser
    if post.author != request.user and not request.user.is_superuser:
        messages.error(request, 'You can only edit your own posts.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES, instance=post)
        if form.is_valid():
            post = form.save(commit=False)
            featured_image_id = request.POST.get('featured_image_id')
            if featured_image_id:
                try:
                    from media_manager.models import MediaFile 
                    media_obj = MediaFile.objects.get(id=featured_image_id)
                    post = form.save(commit=False)
                    post.featured_image = media_obj.file  
                except MediaFile.DoesNotExist:
                    pass
            else:
                post = form.save(commit=False)
            post = form.save(commit=False)
            
            # Handle status
            if 'save_draft' in request.POST:
                post.status = 'draft'
            elif 'publish' in request.POST:
                post.status = 'published'
                if not post.published_date:
                    post.published_date = timezone.now()
            
            # Generate slug if not provided
            if not post.slug and post.title:
                post.slug = generate_unique_slug(post.title, exclude_id=post.id)
            
            post.save()
            
            # Handle categories - get selected category IDs from POST data
            # selected_categories = request.POST.getlist('category')
            # post.category.set(selected_categories)
            
            if post.status == 'published':
                messages.success(request, 'Post updated and published!')
            else:
                messages.success(request, 'Post updated and saved as draft!')
                
            return redirect('edit_post', pk=post.pk)
        else:
            # Add form errors to messages
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
    else:
        form = PostForm(instance=post)
    
    all_categories = Category.objects.all()
    return render(request, 'dashboard/add_post.html', {
        'form': form,
        'post': post,
        'all_categories': all_categories,
    })

@login_required(login_url='login')
def post_form_view(request, pk=None):
    """Unified view for both add and edit post functionality"""
    post = get_object_or_404(Post, pk=pk) if pk else None
    
    # Check permissions for editing
    if post and post.author != request.user and not request.user.is_superuser:
        messages.error(request, 'You can only edit your own posts.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES, instance=post)
        if form.is_valid():
            post = form.save(commit=False)
            featured_image_id = request.POST.get('featured_image_id')
            if featured_image_id:
                try:
                    from media_manager.models import MediaFile  
                    media_obj = MediaFile.objects.get(id=featured_image_id)
                    post = form.save(commit=False)
                    post.featured_image = media_obj.file  
                except MediaFile.DoesNotExist:
                    pass
            else:
                post = form.save(commit=False)
            post_obj = form.save(commit=False)
            
            if not post:  # New post
                post_obj.author = request.user
            
            # Handle status and publish date
            if 'save_draft' in request.POST:
                post_obj.status = 'draft'
            elif 'publish' in request.POST:
                post_obj.status = 'published'
                if not post_obj.published_date:
                    post_obj.published_date = timezone.now()
            
            # Auto-generate slug if needed
            if not post_obj.slug and post_obj.title:
                post_obj.slug = generate_unique_slug(post_obj.title, exclude_id=post_obj.id if post else None)
            
            post_obj.save()
            
            # Handle category (single selection)
            selected_category = request.POST.get('category')
            if selected_category:
                post_obj.category_id = selected_category
            else:
                post_obj.category = None
            
            success_msg = f"Post {'updated' if post else 'created'} and {'published' if post_obj.status == 'published' else 'saved as draft'}!"
            messages.success(request, success_msg)
            
            return redirect('edit_post', pk=post_obj.pk)
        else:
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
    else:
        form = PostForm(instance=post)
    
    return render(request, 'dashboard/add_post.html', {
        'form': form,
        'post': post,
        'all_categories': Category.objects.all(),
    })


<!-- Category -->
<div class="bg-white rounded-lg shadow-sm border border-gray-200">
    <div class="px-4 py-3 border-b border-gray-200">
        <h3 class="text-lg font-medium text-gray-900">Categories</h3>
    </div>
    <div class="p-4 space-y-2">
        {% for category in all_categories %}
            <label class="flex items-center">
                <input type="checkbox" name="category" value="{{ category.id }}" 
                       {% if post and category in post.category.all %}checked{% endif %}
                       class="rounded border-gray-300 text-blue-600 focus:ring-blue-500 mr-2">
                <span class="text-sm text-gray-700">{{ category.category_name }}</span>
            </label>
        {% endfor %}
    </div>
</div>

class Post(BaseContent):
    category = models.ManyToManyField('Category', blank=True, related_name='posts')

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = [
            'title', 'slug', 'content', 'excerpt', 
            'featured_image', 'category', 'seo_description', 
            'seo_keywords', 'published_date'
        ]
        widgets = {
            'title': forms.TextInput(attrs={
                'class': 'w-full px-4 py-3 text-xl border-0 border-b border-gray-300 focus:border-blue-500 focus:outline-none bg-transparent placeholder-gray-500',
                'placeholder': 'Add title',
                'id': 'id_title'
            }),
            'slug': forms.TextInput(attrs={
                'class': 'text-sm px-2 py-1 border-0 border-b border-dashed border-gray-300 focus:border-blue-500 focus:outline-none bg-transparent',
                'id': 'id_slug'
            }),
            'content': CKEditor5Widget(
                config_name='blog',
                attrs={'class': 'django_ckeditor_5'}
            ),
            'excerpt': forms.Textarea(attrs={
                'class': 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent',
                'rows': 3,
                'placeholder': 'Write an excerpt (optional)',
                'id': 'id_excerpt'
            }),
            'seo_description': forms.Textarea(attrs={
                'class': 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent',
                'rows': 3,
                'placeholder': 'SEO meta description',
                'maxlength': '160',
                'id': 'id_seo_description'
            }),
            'seo_keywords': forms.TextInput(attrs={
                'class': 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent',
                'placeholder': 'SEO keywords (comma separated)',
                'id': 'id_seo_keywords'
            }),
            'published_date': forms.DateTimeInput(attrs={
                'class': 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm',
                'type': 'datetime-local',
                'id': 'id_published_date'
            }),
            'featured_image': forms.FileInput(attrs={
                'accept': 'image/*',
                'id': 'id_featured_image',
                'style': 'display: none;'
            }),
            'featured_image_id': forms.HiddenInput(),
        }

def add_post(request):
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES)
        if form.is_valid():
            post = form.save(commit=False)
            featured_image_id = request.POST.get('featured_image_id')
            if featured_image_id:
                try:
                    from media_manager.models import MediaFile  
                    media_obj = MediaFile.objects.get(id=featured_image_id)
                    post = form.save(commit=False)
                    post.featured_image = media_obj.file 
                except MediaFile.DoesNotExist:
                    pass
            else:
                post = form.save(commit=False)
            post.author = request.user
            
            # Handle status
            if 'save_draft' in request.POST:
                post.status = 'draft'
            elif 'publish' in request.POST:
                post.status = 'published'
                if not post.published_date:
                    post.published_date = timezone.now()
            
            # Generate slug if not provided
            if not post.slug and post.title:
                post.slug = generate_unique_slug(post.title)
            
            post.save()
            
            # Handle categories - get selected category IDs from POST data
            selected_categories = request.POST.getlist('category')
            if selected_categories:
                post.category.set(selected_categories)
            
            if post.status == 'published':
                messages.success(request, 'Post published successfully!')
            else:
                messages.success(request, 'Post saved as draft!')
                
            return redirect('edit_post', pk=post.pk)
        else:
            # Add form errors to messages
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
    else:
        form = PostForm()
    
    all_categories = Category.objects.all()
    return render(request, 'dashboard/add_post.html', {
        'form': form,
        'all_categories': all_categories,
    })


def edit_post(request, pk):
    post = get_object_or_404(Post, pk=pk)
    
    # Check if user owns the post or is superuser
    if post.author != request.user and not request.user.is_superuser:
        messages.error(request, 'You can only edit your own posts.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES, instance=post)
        if form.is_valid():
            post = form.save(commit=False)
            featured_image_id = request.POST.get('featured_image_id')
            if featured_image_id:
                try:
                    from media_manager.models import MediaFile 
                    media_obj = MediaFile.objects.get(id=featured_image_id)
                    post = form.save(commit=False)
                    post.featured_image = media_obj.file  
                except MediaFile.DoesNotExist:
                    pass
            else:
                post = form.save(commit=False)
            post = form.save(commit=False)
            
            # Handle status
            if 'save_draft' in request.POST:
                post.status = 'draft'
            elif 'publish' in request.POST:
                post.status = 'published'
                if not post.published_date:
                    post.published_date = timezone.now()
            
            # Generate slug if not provided
            if not post.slug and post.title:
                post.slug = generate_unique_slug(post.title, exclude_id=post.id)
            
            post.save()
            
            # Handle categories - get selected category IDs from POST data
            # selected_categories = request.POST.getlist('category')
            # post.category.set(selected_categories)
            
            if post.status == 'published':
                messages.success(request, 'Post updated and published!')
            else:
                messages.success(request, 'Post updated and saved as draft!')
                
            return redirect('edit_post', pk=post.pk)
        else:
            # Add form errors to messages
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
    else:
        form = PostForm(instance=post)
    
    all_categories = Category.objects.all()
    return render(request, 'dashboard/add_post.html', {
        'form': form,
        'post': post,
        'all_categories': all_categories,
    })

def post_form_view(request, pk=None):
    """Unified view for both add and edit post functionality"""
    post = get_object_or_404(Post, pk=pk) if pk else None
    
    # Check permissions for editing
    if post and post.author != request.user and not request.user.is_superuser:
        messages.error(request, 'You can only edit your own posts.')
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES, instance=post)
        if form.is_valid():
            post = form.save(commit=False)
            featured_image_id = request.POST.get('featured_image_id')
            if featured_image_id:
                try:
                    from media_manager.models import MediaFile  
                    media_obj = MediaFile.objects.get(id=featured_image_id)
                    post = form.save(commit=False)
                    post.featured_image = media_obj.file  
                except MediaFile.DoesNotExist:
                    pass
            else:
                post = form.save(commit=False)
            post_obj = form.save(commit=False)
            
            if not post:  # New post
                post_obj.author = request.user
            
            # Handle status and publish date
            if 'save_draft' in request.POST:
                post_obj.status = 'draft'
            elif 'publish' in request.POST:
                post_obj.status = 'published'
                if not post_obj.published_date:
                    post_obj.published_date = timezone.now()
            
            # Auto-generate slug if needed
            if not post_obj.slug and post_obj.title:
                post_obj.slug = generate_unique_slug(post_obj.title, exclude_id=post_obj.id if post else None)
            
            post_obj.save()
            
            # Handle category (multiple selection)
            selected_categories = request.POST.getlist('category')
            post_obj.save()
            if selected_categories:
                post_obj.category.set(selected_categories)
            else:
                post_obj.category.clear()
            
            success_msg = f"Post {'updated' if post else 'created'} and {'published' if post_obj.status == 'published' else 'saved as draft'}!"
            messages.success(request, success_msg)
            
            return redirect('edit_post', pk=post_obj.pk)
        else:
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
    else:
        form = PostForm(instance=post)
    
    return render(request, 'dashboard/add_post.html', {
        'form': form,
        'post': post,
        'all_categories': Category.objects.all(),
    })

# URL patterns will use:
# add_post = post_form_view
# edit_post = post_form_view (with pk parameter)

def auto_save_post(request):
    """Enhanced auto-save with comprehensive field support"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Invalid request method'})
    
    try:
        data = json.loads(request.body)
        post_id = data.get('post_id')
        
        saveable_fields = ['title', 'content', 'excerpt', 'seo_description', 'seo_keywords', 'slug']
        
        if post_id:
            # Update existing post
            post = get_object_or_404(Post, pk=post_id, author=request.user)
            
            # Update basic fields
            for field in saveable_fields:
                if field in data and data[field] is not None:
                    setattr(post, field, data[field])
            
            # Auto-generate slug if title changed and no custom slug
            if data.get('title') and not data.get('slug'):
                post.slug = generate_unique_slug(data['title'], exclude_id=post.id)
            elif not post.slug:  # Add this line
                post.slug = generate_unique_slug(post.title or 'untitled', exclude_id=post.id)
            
            post.status = 'draft'
            post.save()
            
            # Handle category after saving
            category_id = data.get('category')
            if category_id and category_id != '':
                try:
                    category = Category.objects.get(pk=int(category_id))
                    post.category = category
                    post.save()
                except (Category.DoesNotExist, ValueError, TypeError):
                    pass  # Keep existing category if invalid ID
            
        else:
            # Create new post
            post_data = {field: data.get(field, '') for field in saveable_fields}
            post_data.update({
                'author': request.user,
                'status': 'draft'
            })
            
            if post_data['title'] and not post_data['slug']:
                post_data['slug'] = generate_unique_slug(post_data['title'])
            elif not post_data['slug']:  
                post_data['slug'] = generate_unique_slug('untitled')  
            
            post = Post.objects.create(**post_data)
            
            # Handle category for new post
            category_id = data.get('category')
            if category_id and category_id != '':
                try:
                    category = Category.objects.get(pk=int(category_id))
                    post.category = category
                    post.save()
                except (Category.DoesNotExist, ValueError, TypeError):
                    pass
        
        return JsonResponse({
            'success': True,
            'post_id': post.pk,
            'slug': post.slug,
            'message': 'Auto-saved'
        })
        
    except Exception as e:
        print(f"Auto-save error: {str(e)}")
        return JsonResponse({'success': False, 'error': str(e)})